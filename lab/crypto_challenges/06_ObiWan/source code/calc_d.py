def extended_gcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = extended_gcd(b % a, a)
        return (g, x - (b // a) * y, y)

def mod_inverse(a, m):
    g, x, y = extended_gcd(a, m)
    if g != 1:
        raise ValueError('Modular inverse does not exist')
    else:
        return x % m

def calculate_private_exponent(e, n, plaintext, ciphertext):
    phi_n = (plaintext ** e - ciphertext) % n
    d = mod_inverse(e, phi_n)
    return d

# Example values
e = 17  # public exponent
n = 3885939818809226866639787043363807561348795134092369130950983385470901806736361565466089297128250818994339484840348246849859686706799610146322341287843148253011924185299904669597627551758155800320077912889550691379091497725128289299633986277751193246120847022674590432383681458993045745957361247628898619533833648251443916733282577886721293431036458439415555101097990025528589956459090061384778695974308595402123516471802342910395085919062194938719275688182244497225339097083024039098640715244014285827272513848016293518825950785609827464234980855575137963828480665401893527147121584763680409101485362879563673787527 # modulus
plaintext = 97
ciphertext = 5958260438588051333281183456765537

d = calculate_private_exponent(e, n, plaintext, ciphertext)
print("Private exponent (d):", d)
